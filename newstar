#! /usr/bin/env python

'''
OpenStack Nova shell, taking an excuse to make usability improvements
'''

import os, sys
from os.path import expanduser
from subprocess import Popen, PIPE, call
import time
import cmd, readline
import shlex
from argparse import ArgumentParser
import getpass
import threading, Queue
import yaml
import tempfile

# TODO Show all VMs and filter by status
# TODO Display ERROR details (+ dates)

DIR = expanduser('~/.newstar')
TIMEARGS = '-t', '--time'
TIMEKWARGS = {'action': 'store_true',
              'help':   "measure time spent in operations",
             }
SERVERARGS = 'server',
SERVERKWARGS = {'nargs': '+'}

def wintitle():
    print '\033]0;newstar\007\r', # pylint: disable=W1401

def join(queue):
    try:
        while not queue.empty():
            time.sleep(1) # Interruptible
    except KeyboardInterrupt:
        while not queue.empty():
            queue.get()
            queue.task_done()
    queue.join()

def listworker(vms, listqueue, lock):
    while True:
        url, service, tenant, doprint, dolserror, verbose = listqueue.get()

        # Set tenant
        tenant = tenant['name']

        # Run nova
        proc = Popen(['nova', '--os-auth-url', url, '--os-tenant-name', tenant,
                      'list'], stdout=PIPE)

        output = ''

        # Title
        if verbose:
            output += "%s, %s:\n" % (tenant, service.capitalize())

        # Handle header
        for line, _ in zip(proc.stdout, range(3)):
            if verbose:
                output += line

        # Print VMs
        for line in proc.stdout:
            try:
                server = line.split('|')[2].strip()
                status = line.split('|')[3].strip()
                lock.acquire()
                vms[server] = service, url, tenant
                lock.release()
                if doprint:
                    if dolserror:
                        if status == 'ERROR':
                            if verbose:
                                output += line
                            else:
                                output += server + '\n'
                    else:
                        if verbose:
                            output += line
                        else:
                            output += server + '\n'
            except IndexError:
                if verbose:
                    output += line

        # Wait for process to avoid zombies
        proc.communicate()

        if verbose:
            output += '\n'

        lock.acquire()
        if doprint and output:
            print output,
        lock.release()

        listqueue.task_done()

def vmworker(vms, vmqueue, lock, temp):
    '''
    VM querying thread worker
    '''

    while True:
        operation, server = vmqueue.get()

        try:
            service, url, tenant = vms[server]

            null = open(os.devnull, 'w')
            # Would receive a KeyboardInterrupt too but that's fine
            proc = Popen(['nova', '--os-auth-url', url, '--os-tenant-name',
                          tenant, operation, server], stdout=PIPE, stderr=null)

            # Wait for process to avoid zombies
            output, _ = proc.communicate()

            # Print output
            null.close()
            if output: # Make sure not empty if KeyboardInterrupted
                lock.acquire()
                for fhl in sys.stdout, temp:
                    print >> fhl, "# In %s, %s:" % \
                        (tenant, service.capitalize())
                    print >> fhl, output
                lock.release()
        except KeyError:
            pass
        vmqueue.task_done()

class Cli(cmd.Cmd):
    '''
    CLI
    '''

    def __init__(self, args):
        '''
        Init CLI
        '''

        cmd.Cmd.__init__(self)

        # Set prompt and window title
        self.prompt = 'newstar% '
        wintitle()

        # Read history
        histfile = DIR + '/histfile'
        if os.path.exists(histfile):
            readline.read_history_file(histfile)

        # Argument parsers
        self.listparser = ArgumentParser(prog='list', description="List VMs.")
        self.listparser.add_argument('-v', '--verbose', action='store_true',
                                     help="display VM details" )
        self.listparser.add_argument('-e', '--error', action='store_true',
                                      help="only display VMs in ERROR state")
        self.listparser.add_argument(*TIMEARGS, **TIMEKWARGS)

        self.showparser = ArgumentParser(prog='show',
                                         description="Show VM details.")
        self.showparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.showparser.add_argument(*SERVERARGS, **SERVERKWARGS)

        self.rebootparser = ArgumentParser(prog='reboot',
                                           description="Reboot VMs.")
        self.rebootparser.add_argument('--hard', action='store_true',
                                       help="reboot hard")
        self.rebootparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.rebootparser.add_argument(*SERVERARGS, **SERVERKWARGS)

        self.authparser = ArgumentParser(prog='authenticate',
            description='Authenticate against OpenStack.')
        self.authparser.add_argument('-l', '--login')

        self.pageparser = ArgumentParser(prog='page',
                                         description="Page last output.")

        self.editparser = ArgumentParser(prog='edit',
                                         description="Edit command line.")
        self.editparser.add_argument('command', help="command")
        self.editparser.add_argument('argument', help="arguments", nargs='*')

        self.consoleparser = ArgumentParser(prog='console',
                                            description="Dump console.")
        self.consoleparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.consoleparser.add_argument(*SERVERARGS, **SERVERKWARGS)

        self.lstenantsparser = ArgumentParser(prog='lstenants',
                                              description="List known tenants.")

        # Initialise VM-tenant mapping
        self.vms = {}

        # Credentials
        os.environ['OS_USERNAME'] = getpass.getuser()

        # Config file
        directory = DIR
        if not os.path.isdir(directory):
            os.mkdir(directory)
        yamlfile = directory + '/newstar.yaml'
        if os.path.exists(yamlfile):
            self.config = yaml.load(open(yamlfile))
            self.services = self.config['services']
        else:
            print >> sys.stderr, "Couldn't find %s" % yamlfile
            sys.exit(1)

        # Set page file name
        self.temp = tempfile.NamedTemporaryFile(prefix='page-', dir=DIR)

        # Common thread objects
        self.lock = threading.Lock()

        # Start threads to permanently pull VMs to show the info of
        self.vmqueue = Queue.Queue()
        for _ in range(16): # 16 seems to be the optimal balance
            thread = threading.Thread(target=vmworker,
                                      args=(self.vms, self.vmqueue, self.lock,
                                            self.temp))
            thread.daemon = True # Stop thread when parent process ends
            thread.start()

        # Start threads to permanently list tenants
        self.listqueue = Queue.Queue()
        for _ in range(8): # Shouldn't ever have more than 8 tenants
            thread = threading.Thread(target=listworker,
                                      args=(self.vms, self.listqueue,
                                            self.lock))
            thread.daemon = True # Stop thread when parent process ends
            thread.start()

    def authck(self):
        '''
        Check if user has authenticated
        '''

        # Check authentication
        if 'OS_PASSWORD' not in os.environ:
            print >> sys.stderr, "You need to authenticate first"
            return False
        else:
            return True

    def _list(self, doprint, dolserror=False, verbose=False):
        '''
        List VMs
        '''

        for service in self.services:
            url = self.services[service]['url']
            tenants = self.services[service]['tenants']
            for tenant in tenants:
                self.listqueue.put((url, service, tenant, doprint,
                                    dolserror, verbose))

        join(self.listqueue)

    def precmd(self, line):
        readline.set_pre_input_hook()
        readline.write_history_file(DIR + '/histfile')
        return line

    def emptyline(self):
        '''
        Handle empty lines
        '''

        pass

    def _queryvm(self, parser, line, operation):
        '''
        Query on a per-VM basis
        '''

        # Parse arguments
        try:
            args = parser.parse_args(shlex.split(line))
        except SystemExit:
            return

        if not self.authck():
            return

        # Update VM-tenant mapping
        time0 = time.time()
        if not self.vms:
            self._list(doprint=False)

        # Collect requested servers into queue
        self.temp.seek(0)
        self.temp.truncate()
        for server in args.server:
            self.vmqueue.put((operation, server))

        # Wait until queue is drained
        join(self.vmqueue)
        self.temp.flush()

        if args.time:
            print time.time() - time0
        print '\a\r',

    def do_show(self, line):
        '''
        Show VMs info
        '''

        self._queryvm(self.showparser, line, 'show')

    def do_console(self, line):
        '''
        Dump console
        '''

        self._queryvm(self.consoleparser, line, 'console-log')

    def help_show(self): # pylint: disable=R0201
        '''
        Help with show
        '''

        self.showparser.print_help()

    def do_list(self, line):
        '''
        List VMs
        '''

        # Parse arguments
        try:
            args = self.listparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        if not self.authck():
            return

        # List VMs in all tenants of all OpenStack services
        time0 = time.time()
        self._list(doprint=True, dolserror=args.error, verbose=args.verbose)
        if args.time:
            print time.time() - time0

        print '\a\r',

    def help_list(self): # pylint: disable=R0201
        '''
        Help with list
        '''

        print self.listparser.print_help()

    def do_authenticate(self, line): # pylint: disable=R0201
        '''
        Authenticate
        '''

        # Parse arguments
        try:
            args = self.authparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        if args.login:
            os.environ['OS_USERNAME'] = args.login
        else:
            os.environ['OS_USERNAME'] = getpass.getuser()
        os.environ['OS_PASSWORD'] = getpass.getpass()

    def help_authenticate(self): # pylint: disable=R0201
        '''
        Help with authenticate
        '''

        self.authparser.print_help()

    def do_page(self, line):
        '''
        Page last result
        '''

        # Parse arguments
        try:
            args = self.pageparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        # Parse 
        call(['vim', '-n', '+set nowrap titlestring=newstar', self.temp.name])
        wintitle()

    def help_page(self):
        '''
        Help with paging
        '''
        self.pageparser.print_help()

    def do_edit(self, line):
        '''
        Edit command line
        '''

        # Parse arguments
        try:
            args = self.editparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        # Open command line in editor
        tmpw = tempfile.NamedTemporaryFile(prefix='edit-', dir=DIR)
        print >> tmpw, line
        tmpw.flush()
        call(['vim', '-n', '+set titlestring=newstar', tmpw.name])
        wintitle()

        # Read edited command line
        tmpr = open(tmpw.name)
        line = tmpr.read().strip() # Can't cope with any trailing newline

        def hook():
            '''
            Insert text in command line
            '''

            readline.insert_text(line)
            readline.redisplay()

        readline.set_pre_input_hook(hook)

    def help_edit(self): # pylint: disable=R0201
        '''
        Help with edit
        '''

        self.editparser.print_help()

    def complete_edit(self, text, line, begidx, endidx):
        '''
        Complete command for Vim editing
        '''

        return [cmd[3:] for cmd in dir(self)
                if cmd.startswith('do_') and cmd[3:].startswith(text)]

    def do_lstenants(self, line):
        '''
        List known tenants
        '''

        # Parse arguments
        try:
            args = self.lstenantsparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        for service in self.services:
            tenants = self.services[service]['tenants']
            for tenant in tenants:
                print "'%s' in %s" % (tenant['name'], service.capitalize())

    def help_lstenants(self): # pylint: disable=R0201
        '''
        Help with lstenants
        '''

        self.lstenantsparser.print_help()

    def do_reboot(self, line):
        '''
        Reboot VMs
        '''

        # Parse arguments
        try:
            args = self.rebootparser.parse_args(shlex.split(line))
        except SystemExit:
            return

        if not self.authck():
            return

        # Update VM-tenant mapping
        time0 = time.time()
        self._list(doprint=False)

        for server in args.server:
            try:
                service, url, tenant = self.vms[server]

                call(['nova', '--os-auth-url', url, '--os-tenant-name', tenant,
                      'reboot'] + (['--hard'] if args.hard else []) + [server])
            except KeyError:
                print >> sys.stderr, "Couldn't find %s" % server

        if args.time:
            print time.time() - time0
        print '\a\r',

    def help_reboot(self): # pylint: disable=R0201,C0103
        '''
        Help with rebooting
        '''

        self.rebootparser.print_help()

    def do_EOF(self, _): # pylint: disable=R0201,C0103
        '''
        Handle ^D
        '''

        # For some reason the tempfile isn't closed with the object is detroyed
        self.temp.close()

        print
        sys.exit(0)

    def help_EOF(self): # pylint: disable=R0201,C0103
        '''
        Help with EOF
        '''

        print "Exit. You could also use Ctrl-D."

    def help_help(self): # pylint: disable=R0201
        '''
        Help with help
        '''

        print "Print help"

def main():
    '''
    Main function
    '''

    parser = ArgumentParser(description="Nova shell")
    args = parser.parse_args()
    cli = Cli(args)

    while True:
        try:
            cli.cmdloop()
        except KeyboardInterrupt:
            print

if __name__ == '__main__':
    sys.exit(main())
