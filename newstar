#! /usr/bin/env python

'''
OpenStack Nova shell, taking an excuse to make usability improvements
'''

import os, sys
from os.path import expanduser
from subprocess import Popen, PIPE, call
import time
import cli
from argparse import ArgumentParser
import getpass
import threading, Queue
import yaml

# TODO Show all VMs and filter by status
# TODO Display ERROR details (+ dates)

DIR = expanduser('~/.newstar')
TIMEARGS = '-t', '--time'
TIMEKWARGS = {'action': 'store_true',
              'help':   "measure time spent in operations",
             }
SERVERARGS = 'server',
SERVERKWARGS = {'nargs': '+'}

def join(queue):
    try:
        while not queue.empty():
            time.sleep(1) # Interruptible
    except KeyboardInterrupt:
        while not queue.empty():
            queue.get()
            queue.task_done()
    queue.join()

def listworker(vms, listqueue, lock):
    while True:
        url, service, tenant, servers, doprint, dolserror, dolsbuild, \
            dolsdeleted, verbose = listqueue.get()

        # Set tenant
        tenant = tenant['name']

        # Run nova
        proc = Popen(['nova', '--os-auth-url', url, '--os-tenant-name', tenant,
                      'list'], stdout=PIPE)

        output = ''

        # Title
        if verbose:
            output += "%s, %s:\n" % (tenant, service.capitalize())

        # Handle header
        for _ in range(3):
            if verbose:
                output += proc.stdout.next()

        # Print VMs
        for line in proc.stdout:
            try:
                server = line.split('|')[2].strip()
                status = line.split('|')[3].strip()
                lock.acquire()
                vms[server] = service, url, tenant
                lock.release()
                match = True
                if doprint:
                    if dolserror:
                        match = status == 'ERROR'

                    if dolsbuild:
                        match = status == 'BUILD'

                    if dolsdeleted:
                        match = status == 'DELETED'

                    if servers:
                        match = server in servers

                    if match:
                        if verbose:
                            output += line
                        else:
                            output += server + '\n'
            except IndexError:
                if verbose:
                    output += line

        # Wait for process to avoid zombies
        proc.communicate()

        if verbose:
            output += '\n'

        lock.acquire()
        if doprint and output:
            print output,
        lock.release()

        listqueue.task_done()

def vmworker(vms, vmqueue, lock, temp):
    '''
    VM querying thread worker
    '''

    while True:
        operation, server = vmqueue.get()

        try:
            service, url, tenant = vms[server]

            null = open(os.devnull, 'w')
            # Would receive a KeyboardInterrupt too but that's fine
            proc = Popen(['nova', '--os-auth-url', url, '--os-tenant-name',
                          tenant, operation, server], stdout=PIPE, stderr=null)

            # Wait for process to avoid zombies
            output, _ = proc.communicate()

            # Print output
            null.close()
            if output: # Make sure not empty if KeyboardInterrupted
                lock.acquire()
                for fhl in sys.stdout, temp:
                    print >> fhl, "# In %s, %s:" % \
                        (tenant, service.capitalize())
                    print >> fhl, output
                lock.release()
        except KeyError:
            pass
        vmqueue.task_done()

class Newstar(cli.Cli):
    '''
    CLI
    '''

    def __init__(self, args):
        '''
        Init CLI
        '''

        cli.Cli.__init__(self, True)

        # Argument parsers
        self.listparser.add_argument('-v', '--verbose', action='store_true',
                                     help="display VM details" )
        self.listparser.add_argument('-e', '--error', action='store_true',
                                     help="only display VMs in ERROR state")
        self.listparser.add_argument('-b', '--build', action='store_true',
                                     help="only display VMs in BUILD state")
        self.listparser.add_argument('-d', '--deleted', action='store_true',
                                     help="only display VMs in DELETED state")
        self.listparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.listparser.add_argument(*SERVERARGS, nargs='*')
        self.listparser.description = "List VMs."

        self.showparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.showparser.add_argument(*SERVERARGS, **SERVERKWARGS)
        self.showparser.description = "Show VM details."

        self.rebootparser.add_argument('--hard', action='store_true',
                                       help="reboot hard")
        self.rebootparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.rebootparser.add_argument(*SERVERARGS, **SERVERKWARGS)
        self.rebootparser.description = "Reboot VMs."

        self.authenticateparser.add_argument('-l', '--login')
        self.authenticateparser.description = "Authenticate against OpenStack."

        self.consoleparser.add_argument(*TIMEARGS, **TIMEKWARGS)
        self.consoleparser.add_argument(*SERVERARGS, **SERVERKWARGS)
        self.consoleparser.description = "Dump console."

        self.lstenantsparser.description = "List known tenants."

        # Initialise VM-tenant mapping
        self.vms = {}

        # Credentials
        os.environ['OS_USERNAME'] = getpass.getuser()

        # Config file
        yamlfile = self.directory + '/newstar.yaml'
        if os.path.exists(yamlfile):
            self.config = yaml.load(open(yamlfile))
            self.services = self.config['services']
        else:
            print >> sys.stderr, "Couldn't find %s" % yamlfile
            sys.exit(1)

        # Common thread objects
        self.lock = threading.Lock()

        # Start threads to permanently pull VMs to show the info of
        self.vmqueue = Queue.Queue()
        for _ in range(16): # 16 seems to be the optimal balance
            thread = threading.Thread(target=vmworker,
                                      args=(self.vms, self.vmqueue, self.lock,
                                            self.temp))
            thread.daemon = True # Stop thread when parent process ends
            thread.start()

        # Start threads to permanently list tenants
        self.listqueue = Queue.Queue()
        for _ in range(8): # Shouldn't ever have more than 8 tenants
            thread = threading.Thread(target=listworker,
                                      args=(self.vms, self.listqueue,
                                            self.lock))
            thread.daemon = True # Stop thread when parent process ends
            thread.start()

    def authck(self):
        '''
        Check if user has authenticated
        '''

        # Check authentication
        if 'OS_PASSWORD' not in os.environ:
            print >> sys.stderr, "You need to authenticate first"
            return False
        else:
            return True

    def _list(self, servers=[], doprint=False, dolserror=False, dolsbuild=False,
              dolsdeleted=False, verbose=False):
        '''
        List VMs
        '''

        for service in self.services:
            url = self.services[service]['url']
            tenants = self.services[service]['tenants']
            for tenant in tenants:
                self.listqueue.put((url, service, tenant, servers, doprint,
                                    dolserror, dolsbuild, dolsdeleted, verbose))

        join(self.listqueue)

    def _queryvm(self, args, operation):
        '''
        Query on a per-VM basis
        '''

        if not self.authck():
            return

        # Update VM-tenant mapping
        time0 = time.time()
        if not self.vms:
            self._list(doprint=False)

        # Collect requested servers into queue
        self.tempreset()
        for server in args.server:
            self.vmqueue.put((operation, server))

        # Wait until queue is drained
        join(self.vmqueue)

        if args.time:
            print time.time() - time0
        print '\a\r',

    def run_show(self, args):
        '''
        Show VMs info
        '''

        self._queryvm(args, 'show')

    def run_console(self, args):
        '''
        Dump console
        '''

        self._queryvm(args, 'console-log')

    def run_list(self, args):
        '''
        List VMs
        '''

        # TODO Displays the header in the short version

        if not self.authck():
            return

        # List VMs in all tenants of all OpenStack services
        time0 = time.time()
        self._list(args.server, doprint=True, dolserror=args.error,
                   dolsbuild=args.build, dolsdeleted=args.deleted,
                   verbose=args.verbose)
        if args.time:
            print time.time() - time0

        print '\a\r',

    def run_authenticate(self, args): # pylint: disable=R0201
        '''
        Authenticate
        '''

        if args.login:
            os.environ['OS_USERNAME'] = args.login
        else:
            os.environ['OS_USERNAME'] = getpass.getuser()
        os.environ['OS_PASSWORD'] = getpass.getpass()

    # def complete_edit(self, text, line, begidx, endidx):
    #     '''
    #     Complete command for Vim editing
    #     '''

    #     return [cmd[3:] for cmd in dir(self)
    #             if cmd.startswith('do_') and cmd[3:].startswith(text)]

    def run_lstenants(self, args):
        '''
        List known tenants
        '''

        for service in self.services:
            tenants = self.services[service]['tenants']
            for tenant in tenants:
                print "'%s' in %s" % (tenant['name'], service.capitalize())

    def run_reboot(self, args):
        '''
        Reboot VMs
        '''

        if not self.authck():
            return

        # Update VM-tenant mapping
        time0 = time.time()
        self._list(doprint=False)

        for server in args.server:
            try:
                service, url, tenant = self.vms[server]

                call(['nova', '--os-auth-url', url, '--os-tenant-name', tenant,
                      'reboot'] + (['--hard'] if args.hard else []) + [server])
            except KeyError:
                pass

        if args.time:
            print time.time() - time0
        print '\a\r',

    # def run_EOF(self, _): # pylint: disable=R0201,C0103
    #     '''
    #     Handle ^D
    #     '''

    #     # For some reason the tempfile isn't closed with the object is detroyed
    #     # FIXME Really? Even with Cli?
    #     self.temp.close()

    #     print
    #     sys.exit(0)

def main():
    '''
    Main function
    '''

    parser = ArgumentParser(description="Nova shell")
    args = parser.parse_args()
    Newstar(args).loop()

if __name__ == '__main__':
    sys.exit(main())
